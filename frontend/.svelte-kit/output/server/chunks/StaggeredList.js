import{w as t,g as e}from"./index.js";import{b as s,a}from"./client.js";import"clsx";import{p as r,w as i,j as n,l as o,d as c,k as l,f as h,b as u,u as g,c as m,a as d}from"./index2.js";import{y as p}from"./utils2.js";const y=new class{constructor(t=s){this.client=t,this.supportedSports=["volleyball","table_tennis","soccer"]}validateSport(t){if(!t)throw new Error("スポーツ名が指定されていません");if(!this.supportedSports.includes(t))throw new Error(`サポートされていないスポーツです: ${t}`);return!0}async getTournaments(){try{const t=await this.client.get("/tournaments");return t.success?{success:!0,data:t.data,message:"トーナメント一覧を取得しました"}:t}catch(t){return{success:!1,error:"GET_TOURNAMENTS_ERROR",message:"トーナメント一覧の取得に失敗しました",details:t.message}}}async getTournament(t){try{this.validateSport(t);const e=await this.client.get(`/tournaments/${t}`);return e.success?{success:!0,data:e.data,message:`${t}のトーナメント情報を取得しました`}:e}catch(e){return{success:!1,error:"GET_TOURNAMENT_ERROR",message:"トーナメント情報の取得に失敗しました",details:e.message}}}async getTournamentBracket(t){try{this.validateSport(t);const e=await this.client.get(`/tournaments/${t}/bracket`);return e.success?{success:!0,data:e.data,message:`${t}のブラケット情報を取得しました`}:e}catch(e){return{success:!1,error:"GET_BRACKET_ERROR",message:"ブラケット情報の取得に失敗しました",details:e.message}}}async updateTournamentFormat(t,e){try{if(this.validateSport(t),!e)throw new Error("形式が指定されていません");const s=await this.client.put(`/tournaments/${t}/format`,{format:e});return s.success?{success:!0,data:s.data,message:`${t}のトーナメント形式を${e}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_FORMAT_ERROR",message:"トーナメント形式の更新に失敗しました",details:s.message}}}async createTournament(t){try{const{sport:e,format:s,teams:a}=t;if(this.validateSport(e),!s)throw new Error("トーナメント形式が指定されていません");if(!a||!Array.isArray(a)||0===a.length)throw new Error("参加チーム情報が正しくありません");const r=await this.client.post("/tournaments",{sport:e,format:s,teams:a});return r.success?{success:!0,data:r.data,message:`${e}のトーナメントを作成しました`}:r}catch(e){return{success:!1,error:"CREATE_TOURNAMENT_ERROR",message:"トーナメントの作成に失敗しました",details:e.message}}}async deleteTournament(t){try{this.validateSport(t);const e=await this.client.delete(`/tournaments/${t}`);return e.success?{success:!0,data:e.data,message:`${t}のトーナメントを削除しました`}:e}catch(e){return{success:!1,error:"DELETE_TOURNAMENT_ERROR",message:"トーナメントの削除に失敗しました",details:e.message}}}async updateTournamentStatus(t,e){try{this.validateSport(t);if(!["pending","active","completed","cancelled"].includes(e))throw new Error(`無効なステータスです: ${e}`);const s=await this.client.patch(`/tournaments/${t}/status`,{status:e});return s.success?{success:!0,data:s.data,message:`${t}のトーナメント状態を${e}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_STATUS_ERROR",message:"トーナメント状態の更新に失敗しました",details:s.message}}}async getTournamentStats(t){try{this.validateSport(t);const e=await this.client.get(`/tournaments/${t}/stats`);return e.success?{success:!0,data:e.data,message:`${t}の統計情報を取得しました`}:e}catch(e){return{success:!1,error:"GET_STATS_ERROR",message:"統計情報の取得に失敗しました",details:e.message}}}async getAvailableFormats(t){try{this.validateSport(t);const e=await this.client.get(`/tournaments/${t}/formats`);return e.success?{success:!0,data:e.data,message:`${t}の利用可能な形式一覧を取得しました`}:e}catch(e){return{success:!1,error:"GET_FORMATS_ERROR",message:"形式一覧の取得に失敗しました",details:e.message}}}getSupportedSports(){return{success:!0,data:this.supportedSports,message:"サポートされているスポーツ一覧"}}};const w=new class{constructor(t=s){this.client=t,this.supportedSports=["volleyball","table_tennis","soccer"],this.validStatuses=["pending","in_progress","completed","cancelled"]}validateSport(t){if(!t)throw new Error("スポーツ名が指定されていません");if(!this.supportedSports.includes(t))throw new Error(`サポートされていないスポーツです: ${t}`);return!0}validateMatchId(t){if(!t)throw new Error("試合IDが指定されていません");if("number"!=typeof t&&"string"!=typeof t)throw new Error("試合IDの形式が正しくありません");return!0}validateMatchResult(t){if(!t||"object"!=typeof t)throw new Error("試合結果データが正しくありません");const{score1:e,score2:s,winner:a}=t;if(void 0!==e&&("number"!=typeof e||e<0))throw new Error("チーム1のスコアが正しくありません");if(void 0!==s&&("number"!=typeof s||s<0))throw new Error("チーム2のスコアが正しくありません");if(void 0!==e&&void 0!==s&&void 0!==a&&("string"!=typeof a||""===a.trim()))throw new Error("勝者の情報が正しくありません");return!0}async getMatches(t,e={}){try{this.validateSport(t);const s=new URLSearchParams;e.status&&s.append("status",e.status),e.round&&s.append("round",e.round),e.limit&&s.append("limit",e.limit.toString()),e.offset&&s.append("offset",e.offset.toString());const a=s.toString(),r=`/matches/${t}${a?`?${a}`:""}`,i=await this.client.get(r);return i.success?{success:!0,data:i.data,message:`${t}の試合一覧を取得しました`}:i}catch(s){return{success:!1,error:"GET_MATCHES_ERROR",message:"試合一覧の取得に失敗しました",details:s.message}}}async getMatch(t){try{this.validateMatchId(t);const e=await this.client.get(`/matches/${t}`);return e.success?{success:!0,data:e.data,message:"試合詳細を取得しました"}:e}catch(e){return{success:!1,error:"GET_MATCH_ERROR",message:"試合詳細の取得に失敗しました",details:e.message}}}async updateMatch(t,e){try{this.validateMatchId(t),this.validateMatchResult(e);const s=await this.client.put(`/matches/${t}`,e);return s.success?{success:!0,data:s.data,message:"試合結果を更新しました"}:s}catch(s){return{success:!1,error:"UPDATE_MATCH_ERROR",message:"試合結果の更新に失敗しました",details:s.message}}}async createMatch(t){try{if(!t||"object"!=typeof t)throw new Error("試合データが正しくありません");const{sport:e,tournament_id:s,round:a,team1:r,team2:i,scheduled_at:n}=t;if(!e)throw new Error("スポーツが指定されていません");if(this.validateSport(e),!s)throw new Error("トーナメントIDが指定されていません");if(!a)throw new Error("ラウンドが指定されていません");if(!r||!i)throw new Error("対戦チームが正しく指定されていません");if(r===i)throw new Error("同じチーム同士の試合は作成できません");const o=await this.client.post("/matches",t);return o.success?{success:!0,data:o.data,message:"新しい試合を作成しました"}:o}catch(e){return{success:!1,error:"CREATE_MATCH_ERROR",message:"試合の作成に失敗しました",details:e.message}}}async deleteMatch(t){try{this.validateMatchId(t);const e=await this.client.delete(`/matches/${t}`);return e.success?{success:!0,data:e.data,message:"試合を削除しました"}:e}catch(e){return{success:!1,error:"DELETE_MATCH_ERROR",message:"試合の削除に失敗しました",details:e.message}}}async updateMatchStatus(t,e){try{if(this.validateMatchId(t),!this.validStatuses.includes(e))throw new Error(`無効なステータスです: ${e}`);const s=await this.client.patch(`/matches/${t}/status`,{status:e});return s.success?{success:!0,data:s.data,message:`試合状態を${e}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_MATCH_STATUS_ERROR",message:"試合状態の更新に失敗しました",details:s.message}}}async getPendingMatches(t){try{this.validateSport(t);const e=await this.client.get(`/matches/${t}/pending`);return e.success?{success:!0,data:e.data,message:`${t}の未完了試合一覧を取得しました`}:e}catch(e){return{success:!1,error:"GET_PENDING_MATCHES_ERROR",message:"未完了試合一覧の取得に失敗しました",details:e.message}}}async updateMultipleMatches(t){try{if(!Array.isArray(t)||0===t.length)throw new Error("更新データが正しくありません");for(const s of t){if(!s.matchId)throw new Error("試合IDが指定されていない更新データがあります");this.validateMatchId(s.matchId),this.validateMatchResult(s.result)}const e=await this.client.put("/matches/batch",{updates:t});return e.success?{success:!0,data:e.data,message:`${t.length}件の試合結果を更新しました`}:e}catch(e){return{success:!1,error:"UPDATE_MULTIPLE_MATCHES_ERROR",message:"試合結果の一括更新に失敗しました",details:e.message}}}async getMatchStats(t){try{this.validateMatchId(t);const e=await this.client.get(`/matches/${t}/stats`);return e.success?{success:!0,data:e.data,message:"試合統計情報を取得しました"}:e}catch(e){return{success:!1,error:"GET_MATCH_STATS_ERROR",message:"試合統計情報の取得に失敗しました",details:e.message}}}async getNextMatch(t){try{this.validateSport(t);const e=await this.client.get(`/matches/${t}/next`);return e.success?{success:!0,data:e.data,message:`${t}の次の試合情報を取得しました`}:e}catch(e){return{success:!1,error:"GET_NEXT_MATCH_ERROR",message:"次の試合情報の取得に失敗しました",details:e.message}}}getSupportedSports(){return{success:!0,data:this.supportedSports,message:"サポートされているスポーツ一覧"}}getValidStatuses(){return{success:!0,data:this.validStatuses,message:"有効なステータス一覧"}}};const f=new class{constructor(t={}){this.options={interval:3e4,maxRetries:3,retryDelay:5e3,exponentialBackoff:!0,respectVisibility:!0,enableLogging:!0,...t},this.intervalId=null,this.isPolling=!1,this.retryCount=0,this.lastSuccessTime=null,this.lastErrorTime=null,this.callbacks=new Map,this.errorCallbacks=new Map,this.isPageVisible=!document.hidden,this.setupVisibilityListener(),this.isOnline=navigator.onLine,this.setupNetworkListener()}setupVisibilityListener(){"undefined"!=typeof document&&document.addEventListener("visibilitychange",()=>{this.isPageVisible=!document.hidden,this.options.enableLogging,this.isPageVisible&&this.isPolling&&this.executePoll()})}setupNetworkListener(){"undefined"!=typeof window&&(window.addEventListener("online",()=>{this.isOnline=!0,this.options.enableLogging,this.isPolling&&this.executePoll()}),window.addEventListener("offline",()=>{this.isOnline=!1,this.options.enableLogging}))}registerCallback(t,e){if("function"!=typeof e)throw new Error("Callback must be a function");this.callbacks.set(t,e),this.options.enableLogging}registerErrorCallback(t,e){if("function"!=typeof e)throw new Error("Error callback must be a function");this.errorCallbacks.set(t,e),this.options.enableLogging}unregisterCallback(t){const e=this.callbacks.delete(t);return this.options.enableLogging,e}unregisterErrorCallback(t){const e=this.errorCallbacks.delete(t);return this.options.enableLogging,e}start(){this.isPolling?this.options.enableLogging:(this.isPolling=!0,this.retryCount=0,this.options.enableLogging,this.intervalId=setInterval(()=>{this.executePoll()},this.options.interval))}stop(){this.isPolling&&(this.isPolling=!1,this.intervalId&&(clearInterval(this.intervalId),this.intervalId=null),this.options.enableLogging)}pause(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=null),this.options.enableLogging}resume(){this.isPolling&&!this.intervalId&&(this.intervalId=setInterval(()=>{this.executePoll()},this.options.interval),this.options.enableLogging)}async executePoll(){if(this.isPolling)if(!this.options.respectVisibility||this.isPageVisible)if(this.isOnline)try{this.options.enableLogging;const e=Array.from(this.callbacks.entries()).map(async([t,e])=>{try{return await e(),{key:t,success:!0}}catch(s){return{key:t,success:!1,error:s}}}),s=await Promise.allSettled(e);let a=!1;for(const r of s)if("fulfilled"===r.status&&!r.value.success){a=!0;const e=this.errorCallbacks.get(r.value.key);if(e)try{await e(r.value.error)}catch(t){}}if(a)throw new Error("One or more polling callbacks failed");this.onPollSuccess()}catch(e){this.onPollError(e)}else this.options.enableLogging;else this.options.enableLogging}onPollSuccess(){this.lastSuccessTime=Date.now(),this.retryCount=0,this.options.enableLogging}async onPollError(t){if(this.lastErrorTime=Date.now(),this.retryCount++,this.retryCount>=this.options.maxRetries)return a.showNotification("データの更新に失敗しました。ネットワーク接続を確認してください。","error",1e4),void(this.retryCount=0);const e=this.calculateRetryDelay();this.options.enableLogging,setTimeout(()=>{this.isPolling&&this.executePoll()},e)}calculateRetryDelay(){if(!this.options.exponentialBackoff)return this.options.retryDelay;const t=this.options.retryDelay*Math.pow(2,this.retryCount-1);return Math.min(t,6e4)}setInterval(t){if("number"!=typeof t||t<1e3)throw new Error("Interval must be a number >= 1000ms");this.options.interval=t,this.isPolling&&(this.pause(),this.resume()),this.options.enableLogging}getStats(){return{isPolling:this.isPolling,isPageVisible:this.isPageVisible,isOnline:this.isOnline,interval:this.options.interval,retryCount:this.retryCount,lastSuccessTime:this.lastSuccessTime,lastErrorTime:this.lastErrorTime,callbackCount:this.callbacks.size,errorCallbackCount:this.errorCallbacks.size}}destroy(){this.stop(),this.callbacks.clear(),this.errorCallbacks.clear(),this.options.enableLogging}}({interval:3e4,maxRetries:3,retryDelay:5e3,exponentialBackoff:!0,respectVisibility:!0,enableLogging:!1});class b{constructor(t,e={}){this.data=t,this.timestamp=Date.now(),this.ttl=e.ttl||3e5,this.tags=e.tags||[],this.priority=e.priority||1,this.accessCount=0,this.lastAccessed=this.timestamp}isValid(){return Date.now()-this.timestamp<this.ttl}access(){return this.accessCount++,this.lastAccessed=Date.now(),this.data}getRemainingTTL(){const t=this.ttl-(Date.now()-this.timestamp);return Math.max(0,t)}}class E{constructor(t={}){this.options={maxSize:100,defaultTTL:3e5,cleanupInterval:6e4,enableLogging:!1,...t},this.cache=new Map,this.stats={hits:0,misses:0,sets:0,deletes:0,evictions:0},this.startCleanup()}set(t,e,s={}){if(!t)throw new Error("Cache key is required");const a=s.ttl||this.options.defaultTTL,r=new b(e,{ttl:a,tags:s.tags,priority:s.priority});return this.cache.size>=this.options.maxSize&&!this.cache.has(t)&&this.evictLRU(),this.cache.set(t,r),this.stats.sets++,this.options.enableLogging,!0}get(t){if(!t)return null;const e=this.cache.get(t);return e?e.isValid()?(this.stats.hits++,this.options.enableLogging,e.access()):(this.cache.delete(t),this.stats.misses++,this.options.enableLogging,null):(this.stats.misses++,null)}delete(t){const e=this.cache.delete(t);return e&&(this.stats.deletes++,this.options.enableLogging),e}invalidateByTag(t){const e=Array.isArray(t)?t:[t];let s=0;for(const[a,r]of this.cache.entries())r.tags&&r.tags.some(t=>e.includes(t))&&(this.cache.delete(a),s++);return this.options.enableLogging,s}clear(){const t=this.cache.size;return this.cache.clear(),this.options.enableLogging,t}evictLRU(){let t=null,e=Date.now();for(const[s,a]of this.cache.entries())a.lastAccessed<=e&&(e=a.lastAccessed,t=s);t&&(this.cache.delete(t),this.stats.evictions++,this.options.enableLogging)}cleanup(){let t=0;for(const[e,s]of this.cache.entries())s.isValid()||(this.cache.delete(e),t++);return this.options.enableLogging,t}startCleanup(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.cleanupInterval=setInterval(()=>{this.cleanup()},this.options.cleanupInterval)}stopCleanup(){this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=null)}getStats(){const t=this.stats.hits+this.stats.misses>0?(this.stats.hits/(this.stats.hits+this.stats.misses)*100).toFixed(2):0;return{...this.stats,size:this.cache.size,maxSize:this.options.maxSize,hitRate:`${t}%`}}getInfo(){const t=[];for(const[e,s]of this.cache.entries())t.push({key:e,size:JSON.stringify(s.data).length,ttl:s.ttl,remainingTTL:s.getRemainingTTL(),accessCount:s.accessCount,lastAccessed:s.lastAccessed,tags:s.tags,priority:s.priority,isValid:s.isValid()});return{entries:t,stats:this.getStats(),options:this.options}}destroy(){this.stopCleanup(),this.clear()}}class v{constructor(t={}){this.options={storage:"localStorage",prefix:"cache_",defaultTTL:36e5,enableLogging:!1,...t},this.storage="sessionStorage"===this.options.storage?sessionStorage:localStorage}getStorageKey(t){return`${this.options.prefix}${t}`}set(t,e,s={}){if(!t)throw new Error("Cache key is required");try{const a=s.ttl||this.options.defaultTTL,r={data:e,timestamp:Date.now(),ttl:a},i=this.getStorageKey(t);return this.storage.setItem(i,JSON.stringify(r)),this.options.enableLogging,!0}catch(a){return!1}}get(t){if(!t)return null;try{const e=this.getStorageKey(t),s=this.storage.getItem(e);if(!s)return null;const a=JSON.parse(s);return Date.now()-a.timestamp>a.ttl?(this.storage.removeItem(e),this.options.enableLogging,null):(this.options.enableLogging,a.data)}catch(e){return null}}delete(t){try{const e=this.getStorageKey(t);return this.storage.removeItem(e),this.options.enableLogging,!0}catch(e){return!1}}clear(){try{const t=[];for(let e=0;e<this.storage.length;e++){const s=this.storage.key(e);s&&s.startsWith(this.options.prefix)&&t.push(s)}return t.forEach(t=>{this.storage.removeItem(t)}),this.options.enableLogging,t.length}catch(t){return 0}}cleanup(){try{const e=[];for(let s=0;s<this.storage.length;s++){const a=this.storage.key(s);if(a&&a.startsWith(this.options.prefix))try{const t=this.storage.getItem(a);if(t){const s=JSON.parse(t);Date.now()-s.timestamp>s.ttl&&e.push(a)}}catch(t){e.push(a)}}return e.forEach(t=>{this.storage.removeItem(t)}),this.options.enableLogging&&e.length,e.length}catch(e){return 0}}}const T=new class{constructor(t={}){this.options={enableMemoryCache:!0,enableBrowserCache:!0,memoryFirst:!0,...t},this.options.enableMemoryCache&&(this.memoryCache=new E(t.memory)),this.options.enableBrowserCache&&(this.browserCache=new v(t.browser))}async set(t,e,s={}){const a={};return this.memoryCache&&(a.memory=this.memoryCache.set(t,e,s)),this.browserCache&&!1!==s.persistent&&(a.browser=this.browserCache.set(t,e,s)),a}async get(t){if(this.options.memoryFirst&&this.memoryCache){const e=this.memoryCache.get(t);if(null!==e)return e}if(this.browserCache){const e=this.browserCache.get(t);if(null!==e)return this.memoryCache&&this.memoryCache.set(t,e),e}return!this.options.memoryFirst&&this.memoryCache?this.memoryCache.get(t):null}async delete(t){const e={};return this.memoryCache&&(e.memory=this.memoryCache.delete(t)),this.browserCache&&(e.browser=this.browserCache.delete(t)),e}async invalidateByTag(t){const e={};return this.memoryCache&&(e.memory=this.memoryCache.invalidateByTag(t)),e.browser=0,e}async clear(){const t={};return this.memoryCache&&(t.memory=this.memoryCache.clear()),this.browserCache&&(t.browser=this.browserCache.clear()),t}async cleanup(){const t={};return this.memoryCache&&(t.memory=this.memoryCache.cleanup()),this.browserCache&&(t.browser=this.browserCache.cleanup()),t}getStats(){return{memory:this.memoryCache?this.memoryCache.getStats():null,browser:this.browserCache?"Available":null}}destroy(){this.memoryCache&&this.memoryCache.destroy()}}({memory:{maxSize:100,defaultTTL:3e5,enableLogging:!1},browser:{storage:"localStorage",prefix:"tournament_cache_",defaultTTL:36e5,enableLogging:!1}});async function R(t,e,s={}){const a=s.cache||T,r=await a.get(t);if(null!==r)return r;try{const r=await e();return await a.set(t,r,s),r}catch(i){if(s.staleWhileRevalidate){const e=await a.get(t);if(null!==e)return e}throw i}}const C={tournaments:{},currentSport:"volleyball",loading:!1,error:null,lastUpdated:null,cache:{},pollingInterval:null},{subscribe:S,set:L,update:_}=t(C),I=3e5,$=["volleyball","table_tennis","soccer"];function A(t){_(e=>({...e,loading:t}))}function M(t){_(e=>({...e,error:t,loading:!1}))}function O(){_(t=>({...t,error:null}))}function P(t){if(!t)throw new Error("スポーツ名が指定されていません");if(!$.includes(t))throw new Error(`サポートされていないスポーツです: ${t}`);return!0}async function k(t=null,e=!0){try{if(O(),t){P(t),A(!0);const s=`tournament_${t}`,a=()=>y.getTournament(t),r=e?await R(s,a,{cache:T,ttl:I,tags:["tournament",t],staleWhileRevalidate:!0}):await a();return r.success?(_(e=>({...e,tournaments:{...e.tournaments,[t]:r.data},loading:!1,lastUpdated:Date.now()})),r):(M(r.message||"トーナメントデータの取得に失敗しました"),r)}{A(!0);const t="tournaments_all",s=()=>y.getTournaments(),a=e?await R(t,s,{cache:T,ttl:I,tags:["tournament","all"],staleWhileRevalidate:!0}):await s();return a.success?(_(t=>({...t,tournaments:a.data,loading:!1,lastUpdated:Date.now()})),a):(M(a.message||"トーナメントデータの取得に失敗しました"),a)}}catch(s){return M(s.message||"予期しないエラーが発生しました"),{success:!1,error:"FETCH_TOURNAMENTS_ERROR",message:s.message||"トーナメントデータの取得に失敗しました"}}}async function x(t=null){try{O();const s=e({subscribe:S}),a=t||s.currentSport;await k(a,!1);return{success:!0,message:"データを更新しました"}}catch(s){return M(s.message||"データの更新に失敗しました"),{success:!1,error:"REFRESH_DATA_ERROR",message:s.message||"データの更新に失敗しました"}}}function D(){e({subscribe:S}).pollingInterval||(f.registerCallback("tournament-data",async()=>{e({subscribe:S}).loading||await x()}),f.registerErrorCallback("tournament-data",async t=>{M("データの更新中にエラーが発生しました")}),f.start(),_(t=>({...t,pollingInterval:"active"})))}function N(){f.unregisterCallback("tournament-data"),f.unregisterErrorCallback("tournament-data");0===f.getStats().callbackCount&&f.stop(),_(t=>({...t,pollingInterval:null}))}const U={subscribe:S,fetchTournaments:k,updateMatch:async function(t,s){try{if(O(),!t)throw new Error("試合IDが指定されていません");if(!s||"object"!=typeof s)throw new Error("試合結果データが正しくありません");A(!0);const a=await w.updateMatch(t,s);if(a.success){const t=e({subscribe:S}).currentSport;return await T.invalidateByTag(["tournament",t]),await k(t,!1),{success:!0,data:a.data,message:"試合結果を更新しました"}}return M(a.message||"試合結果の更新に失敗しました"),a}catch(a){return M(a.message||"予期しないエラーが発生しました"),{success:!1,error:"UPDATE_MATCH_ERROR",message:a.message||"試合結果の更新に失敗しました"}}},switchSport:function(t){try{return P(t),_(e=>({...e,currentSport:t,error:null})),k(t),{success:!0,message:`スポーツを${t}に切り替えました`}}catch(e){return M(e.message||"スポーツの切り替えに失敗しました"),{success:!1,error:"SWITCH_SPORT_ERROR",message:e.message||"スポーツの切り替えに失敗しました"}}},refreshData:x,initialize:async function(){try{return await k(),D(),"undefined"!=typeof document&&document.addEventListener("visibilitychange",()=>{document.hidden||x()}),{success:!0,message:"トーナメントストアを初期化しました"}}catch(t){return M(t.message||"初期化に失敗しました"),{success:!1,error:"INITIALIZE_ERROR",message:t.message||"初期化に失敗しました"}}},cleanup:function(){return N(),L(C),{success:!0,message:"トーナメントストアをクリーンアップしました"}},startPolling:D,stopPolling:N,clearCache:async function(t=null){try{return t?await T.invalidateByTag(["tournament",t]):await T.invalidateByTag(["tournament"]),{success:!0,message:t?`${t}のキャッシュをクリアしました`:"トーナメントキャッシュをクリアしました"}}catch(e){return{success:!1,error:"CLEAR_CACHE_ERROR",message:"キャッシュのクリアに失敗しました"}}},getCacheStats:function(){return T.getStats()},getCurrentTournament:function(){const t=e({subscribe:S});return t.tournaments[t.currentSport]||null},getTournamentBySport:function(t){return P(t),e({subscribe:S}).tournaments[t]||null},getSupportedSports:function(){return[...$]},setLoading:A,setError:M,clearError:O};function V(e,s){var a;r();let y=p(s.items,()=>[],!0),w=p(s.staggerDelay,100),f=p(s.animationType,"fadeInUp"),b=p(s.className,""),E=p(s.itemClassName,""),v=p(s.tag,"div"),T=p(s.itemTag,"div");const R=t([]);function C(t){return`animate-${f} stagger-item-${t}`}i(e,v,()=>{e.out.push(`${c(`staggered-list ${h(b)}`,"svelte-12xptd")}`)},()=>{const t=n(o(a??={},"$visibleItems",R));e.out.push("\x3c!--[--\x3e");for(let a=0,r=t.length;a<r;a++){let r=t[a];i(e,T,()=>{e.out.push(`${c(`stagger-item ${h(E)} ${h(C(a))}`,"svelte-12xptd")}${l(`animation-delay: ${h(a*(w/1e3))}s`)}`)},()=>{e.out.push("\x3c!----\x3e"),u(e,s,"default",{item:r,index:a}),e.out.push("\x3c!----\x3e")})}e.out.push("\x3c!--]--\x3e")}),a&&g(a),m(s,{items:y,staggerDelay:w,animationType:f,className:b,itemClassName:E,tag:v,itemTag:T}),d()}export{V as S,U as t};
