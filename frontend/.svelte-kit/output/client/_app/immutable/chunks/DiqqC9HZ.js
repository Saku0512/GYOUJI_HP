import{w as e}from"./BRFgxvOq.js";const t={notifications:[],loading:!1,theme:"light"},s=e(t);let r=0;const a={showNotification:(e,t="info",n=5e3)=>{const i={id:++r,message:e,type:t,timestamp:Date.now()};return s.update(e=>({...e,notifications:[...e.notifications,i]})),n>0&&setTimeout(()=>{a.removeNotification(i.id)},n),i.id},removeNotification:e=>{s.update(t=>({...t,notifications:t.notifications.filter(t=>t.id!==e)}))},setLoading:e=>{s.update(t=>({...t,loading:Boolean(e)}))},clearNotifications:()=>{s.update(e=>({...e,notifications:[]}))},setTheme:e=>{"light"!==e&&"dark"!==e||(s.update(t=>({...t,theme:e})),"undefined"!=typeof localStorage&&localStorage.setItem("ui-theme",e))},loadTheme:()=>{if("undefined"!=typeof localStorage){const e=localStorage.getItem("ui-theme");!e||"light"!==e&&"dark"!==e||a.setTheme(e)}},reset:()=>{s.set(t)}},n={NETWORK:"NETWORK_ERROR",API:"API_ERROR",VALIDATION:"VALIDATION_ERROR",AUTHENTICATION:"AUTHENTICATION_ERROR",AUTHORIZATION:"AUTHORIZATION_ERROR",TIMEOUT:"TIMEOUT_ERROR",PARSE:"PARSE_ERROR",UNKNOWN:"UNKNOWN_ERROR",CLIENT:"CLIENT_ERROR",SERVER:"SERVER_ERROR"},i={LOW:"low",MEDIUM:"medium",HIGH:"high",CRITICAL:"critical"};class o extends Error{constructor(e,t=n.UNKNOWN,s=i.MEDIUM,r=null){super(e),this.name="AppError",this.type=t,this.level=s,this.details=r,this.timestamp=(new Date).toISOString(),this.userAgent="undefined"!=typeof navigator?navigator.userAgent:"Unknown"}toJSON(){return{name:this.name,message:this.message,type:this.type,level:this.level,details:this.details,timestamp:this.timestamp,userAgent:this.userAgent,stack:this.stack}}}const c=new class{constructor(){this.errorListeners=[],this.retryAttempts=new Map,this.maxRetryAttempts=3,this.retryDelay=1e3,this.isInitialized=!1}initialize(){this.isInitialized||"undefined"==typeof window||(window.addEventListener("error",this.handleGlobalError.bind(this)),window.addEventListener("unhandledrejection",this.handleUnhandledRejection.bind(this)),window.addEventListener("auth:unauthorized",this.handleAuthError.bind(this)),this.isInitialized=!0)}addErrorListener(e){this.errorListeners.push(e)}removeErrorListener(e){const t=this.errorListeners.indexOf(e);t>-1&&this.errorListeners.splice(t,1)}handleGlobalError(e){const t=new o(e.message||"JavaScript実行エラーが発生しました",n.CLIENT,i.HIGH,{filename:e.filename,lineno:e.lineno,colno:e.colno,error:e.error});this.handleError(t)}handleUnhandledRejection(e){const t=new o(e.reason?.message||"Promise処理でエラーが発生しました",n.CLIENT,i.HIGH,{reason:e.reason,promise:e.promise});this.handleError(t),e.preventDefault()}handleAuthError(e){const t=new o("認証が無効になりました。再度ログインしてください。",n.AUTHENTICATION,i.MEDIUM);this.handleError(t)}handleError(e,t={}){return e instanceof o||(e=this.normalizeError(e)),Object.keys(t).length>0&&(e.details={...e.details,context:t}),this.logError(e),this.notifyErrorListeners(e),this.notifyUser(e),e.level===i.CRITICAL&&this.handleCriticalError(e),e}normalizeError(e){if(e instanceof o)return e;let t=n.UNKNOWN,s=i.MEDIUM,r=e.message||"エラーが発生しました";return"TypeError"===e.name&&e.message.includes("fetch")?(t=n.NETWORK,r="ネットワークエラーが発生しました"):"AbortError"===e.name?(t=n.TIMEOUT,r="リクエストがタイムアウトしました"):"SyntaxError"===e.name&&(t=n.PARSE,r="データの解析に失敗しました"),new o(r,t,s,{originalError:e,stack:e.stack})}logError(e){e.timestamp,e.type,e.level,e.message,e.details,e.stack;e.level}notifyErrorListeners(e){this.errorListeners.forEach(t=>{try{t(e)}catch(s){}})}notifyUser(e){if(e.level===i.LOW)return;let t="error";e.level===i.MEDIUM&&(t="warning");const s=this.getUserFriendlyMessage(e);a.showNotification(s,t,8e3)}getUserFriendlyMessage(e){switch(e.type){case n.NETWORK:return"インターネット接続を確認してください。";case n.TIMEOUT:return"リクエストがタイムアウトしました。しばらく待ってから再試行してください。";case n.AUTHENTICATION:return"認証が必要です。ログインしてください。";case n.AUTHORIZATION:return"この操作を実行する権限がありません。";case n.VALIDATION:return"入力内容を確認してください。";case n.SERVER:return"サーバーエラーが発生しました。しばらく待ってから再試行してください。";default:return e.message||"エラーが発生しました。"}}handleCriticalError(e){}async retry(e,t,s=this.maxRetryAttempts){const r=this.retryAttempts.get(t)||0;try{const s=await e();return this.retryAttempts.delete(t),s}catch(a){if(r<s){this.retryAttempts.set(t,r+1);const a=this.retryDelay*Math.pow(2,r);return await new Promise(e=>setTimeout(e,a)),this.retry(e,t,s)}throw this.retryAttempts.delete(t),new o(`操作が${s}回失敗しました: ${a.message}`,n.UNKNOWN,i.HIGH,{originalError:a,attempts:s})}}resetErrorBoundary(e){this.retryAttempts.delete(e)}cleanup(){"undefined"!=typeof window&&(window.removeEventListener("error",this.handleGlobalError.bind(this)),window.removeEventListener("unhandledrejection",this.handleUnhandledRejection.bind(this)),window.removeEventListener("auth:unauthorized",this.handleAuthError.bind(this))),this.errorListeners=[],this.retryAttempts.clear(),this.isInitialized=!1}},u=()=>{c.initialize()},h=(e,t={})=>{let s=n.API,r=i.MEDIUM;e.status>=400&&e.status<500?(s=n.CLIENT,401===e.status?s=n.AUTHENTICATION:403===e.status?s=n.AUTHORIZATION:422===e.status&&(s=n.VALIDATION)):e.status>=500&&(s=n.SERVER,r=i.HIGH);const a=new o(e.message||`HTTP ${e.status}: ${e.statusText}`,s,r,{status:e.status,statusText:e.statusText,error:e.error,details:e.details,...t});return c.handleError(a,t)};const d=new class{constructor(e="http://localhost:8080/api"){this.baseURL=e,this.token=null,this.requestInterceptors=[],this.responseInterceptors=[],this.defaultTimeout=3e4,this.retryConfig={maxAttempts:3,retryableErrors:[n.NETWORK,n.TIMEOUT],retryDelay:1e3}}setToken(e){this.token=e}getToken(){return this.token}addRequestInterceptor(e){this.requestInterceptors.push(e)}addResponseInterceptor(e){this.responseInterceptors.push(e)}getHeaders(e={}){const t={"Content-Type":"application/json",...e};return this.token&&(t.Authorization=`Bearer ${this.token}`),t}async applyRequestInterceptors(e){let t={...e};for(const r of this.requestInterceptors)try{t=await r(t)}catch(s){}return t}async applyResponseInterceptors(e){let t=e;for(const r of this.responseInterceptors)try{t=await r(t)}catch(s){}return t}async request(e,t={}){const s=`${this.baseURL}${e}`,r=`${t.method||"GET"}-${e}-${Date.now()}`,a={method:"GET",headers:this.getHeaders(t.headers),signal:this.createAbortSignal(t.timeout||this.defaultTimeout),...t},n=await this.applyRequestInterceptors(a);return this.shouldRetryRequest(t)?(i=()=>this.executeRequest(s,n),o=r,u=this.retryConfig.maxAttempts,c.retry(i,o,u)):this.executeRequest(s,n);var i,o,u}async executeRequest(e,t){try{const s=await fetch(e,t),r=await this.applyResponseInterceptors(s);return await this.handleResponse(r)}catch(s){return this.handleError(s)}}createAbortSignal(e){if("undefined"==typeof AbortController)return;const t=new AbortController;return e>0&&setTimeout(()=>{t.abort()},e),t.signal}shouldRetryRequest(e){if(!1===e.retry)return!1;const t=(e.method||"GET").toUpperCase();return"GET"===t||"HEAD"===t||!0===e.retry}async get(e,t={}){return this.request(e,{...t,method:"GET"})}async post(e,t,s={}){return this.request(e,{...s,method:"POST",body:t?JSON.stringify(t):void 0})}async put(e,t,s={}){return this.request(e,{...s,method:"PUT",body:t?JSON.stringify(t):void 0})}async delete(e,t={}){return this.request(e,{...t,method:"DELETE"})}async patch(e,t,s={}){return this.request(e,{...s,method:"PATCH",body:t?JSON.stringify(t):void 0})}async handleResponse(e){const t=e.headers.get("content-type");try{let s;if(s=t&&t.includes("application/json")?await e.json():await e.text(),e.ok)return{success:!0,data:s,status:e.status,statusText:e.statusText};{const t={success:!1,error:s.error||"HTTP_ERROR",message:s.message||`HTTP ${e.status}: ${e.statusText}`,status:e.status,statusText:e.statusText,details:s.details||null};return h(t),t}}catch(s){const t={success:!1,error:"PARSE_ERROR",message:"レスポンスの解析に失敗しました",status:e.status,statusText:e.statusText,details:s.message};return new o(t.message,n.PARSE,i.MEDIUM,t.details),h(t),t}}handleError(e){let t;return"TypeError"===e.name&&e.message.includes("fetch")?(t={success:!1,error:"NETWORK_ERROR",message:"ネットワークエラーが発生しました。接続を確認してください。",details:e.message},((e,t={})=>{const s=new o("ネットワーク接続に問題があります",n.NETWORK,i.MEDIUM,{originalError:e,...t});c.handleError(s,t)})(e)):"AbortError"===e.name?(t={success:!1,error:"TIMEOUT_ERROR",message:"リクエストがタイムアウトしました。",details:e.message},new o(t.message,n.TIMEOUT,i.MEDIUM,{originalError:e}),h(t)):(t={success:!1,error:"UNKNOWN_ERROR",message:"予期しないエラーが発生しました。",details:e.message},new o(t.message,n.UNKNOWN,i.HIGH,{originalError:e}),h(t)),t}async healthCheck(){try{return(await this.get("/health")).success}catch(e){return!1}}};d.addRequestInterceptor(async e=>e),d.addResponseInterceptor(async e=>(401===e.status&&(d.setToken(null),"undefined"!=typeof window&&localStorage.removeItem("auth_token"),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("auth:unauthorized"))),e));const l=new class{constructor(e=d){this.client=e,this.tokenKey="auth_token",this.refreshTokenKey="refresh_token",this.userKey="auth_user"}getStoredToken(){return"undefined"==typeof window?null:localStorage.getItem(this.tokenKey)}getStoredRefreshToken(){return"undefined"==typeof window?null:localStorage.getItem(this.refreshTokenKey)}getStoredUser(){if("undefined"==typeof window)return null;const e=localStorage.getItem(this.userKey);try{return e?JSON.parse(e):null}catch(t){return null}}storeToken(e,t=null,s=null){"undefined"!=typeof window&&(localStorage.setItem(this.tokenKey,e),t&&localStorage.setItem(this.refreshTokenKey,t),s&&localStorage.setItem(this.userKey,JSON.stringify(s)),this.client.setToken(e))}clearStoredAuth(){"undefined"!=typeof window&&(localStorage.removeItem(this.tokenKey),localStorage.removeItem(this.refreshTokenKey),localStorage.removeItem(this.userKey),this.client.setToken(null))}isTokenExpired(e){if(!e)return!0;try{const t=JSON.parse(atob(e.split(".")[1])),s=Math.floor(Date.now()/1e3);return t.exp<s}catch(t){return!0}}initializeAuth(){const e=this.getStoredToken();return e&&!this.isTokenExpired(e)?(this.client.setToken(e),!0):(e&&this.clearStoredAuth(),!1)}async login(e,t){try{const s=await this.client.post("/auth/login",{username:e,password:t});if(s.success&&s.data){const{token:e,refresh_token:t,user:r}=s.data;return this.storeToken(e,t,r),{success:!0,data:{token:e,refresh_token:t,user:r},message:"ログインに成功しました"}}return s}catch(s){return{success:!1,error:"LOGIN_ERROR",message:"ログインに失敗しました",details:s.message}}}async logout(){try{return this.getStoredToken()&&await this.client.post("/auth/logout"),this.clearStoredAuth(),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("auth:logout")),{success:!0,message:"ログアウトしました"}}catch(e){return this.clearStoredAuth(),{success:!0,message:"ログアウトしました",warning:"サーバーとの通信でエラーが発生しましたが、ローカルの認証情報はクリアされました"}}}async refreshToken(){try{const e=this.getStoredRefreshToken();if(!e)return{success:!1,error:"NO_REFRESH_TOKEN",message:"リフレッシュトークンが見つかりません"};const t=await this.client.post("/auth/refresh",{refresh_token:e});if(t.success&&t.data){const{token:s,refresh_token:r,user:a}=t.data;return this.storeToken(s,r||e,a),{success:!0,data:{token:s,refresh_token:r||e,user:a},message:"トークンを更新しました"}}return this.clearStoredAuth(),t}catch(e){return this.clearStoredAuth(),{success:!1,error:"REFRESH_ERROR",message:"トークンの更新に失敗しました",details:e.message}}}async validateToken(){try{const e=this.getStoredToken();if(!e)return{success:!1,error:"NO_TOKEN",message:"トークンが見つかりません"};if(this.isTokenExpired(e)){const e=await this.refreshToken();return e.success?{success:!0,data:e.data,message:"トークンを更新して検証しました"}:{success:!1,error:"TOKEN_EXPIRED",message:"トークンの期限が切れています"}}const t=await this.client.get("/auth/validate");return t.success?{success:!0,data:t.data,message:"トークンは有効です"}:(this.clearStoredAuth(),t)}catch(e){return{success:!1,error:"VALIDATION_ERROR",message:"トークンの検証に失敗しました",details:e.message}}}getAuthState(){const e=this.getStoredToken(),t=this.getStoredUser();return{isAuthenticated:!(!e||this.isTokenExpired(e)),token:e,user:t}}setupAutoRefresh(e=50){if("undefined"==typeof window)return;setInterval(async()=>{const e=this.getStoredToken();if(e&&!this.isTokenExpired(e))try{const t=JSON.parse(atob(e.split(".")[1])),s=Math.floor(Date.now()/1e3);t.exp-s<600&&await this.refreshToken()}catch(t){}},60*e*1e3)}};"undefined"!=typeof window&&(l.initializeAuth(),l.setupAutoRefresh());const m=new class{constructor(e=d){this.client=e,this.supportedSports=["volleyball","table_tennis","soccer"]}validateSport(e){if(!e)throw new Error("スポーツ名が指定されていません");if(!this.supportedSports.includes(e))throw new Error(`サポートされていないスポーツです: ${e}`);return!0}async getTournaments(){try{const e=await this.client.get("/tournaments");return e.success?{success:!0,data:e.data,message:"トーナメント一覧を取得しました"}:e}catch(e){return{success:!1,error:"GET_TOURNAMENTS_ERROR",message:"トーナメント一覧の取得に失敗しました",details:e.message}}}async getTournament(e){try{this.validateSport(e);const t=await this.client.get(`/tournaments/${e}`);return t.success?{success:!0,data:t.data,message:`${e}のトーナメント情報を取得しました`}:t}catch(t){return{success:!1,error:"GET_TOURNAMENT_ERROR",message:"トーナメント情報の取得に失敗しました",details:t.message}}}async getTournamentBracket(e){try{this.validateSport(e);const t=await this.client.get(`/tournaments/${e}/bracket`);return t.success?{success:!0,data:t.data,message:`${e}のブラケット情報を取得しました`}:t}catch(t){return{success:!1,error:"GET_BRACKET_ERROR",message:"ブラケット情報の取得に失敗しました",details:t.message}}}async updateTournamentFormat(e,t){try{if(this.validateSport(e),!t)throw new Error("形式が指定されていません");const s=await this.client.put(`/tournaments/${e}/format`,{format:t});return s.success?{success:!0,data:s.data,message:`${e}のトーナメント形式を${t}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_FORMAT_ERROR",message:"トーナメント形式の更新に失敗しました",details:s.message}}}async createTournament(e){try{const{sport:t,format:s,teams:r}=e;if(this.validateSport(t),!s)throw new Error("トーナメント形式が指定されていません");if(!r||!Array.isArray(r)||0===r.length)throw new Error("参加チーム情報が正しくありません");const a=await this.client.post("/tournaments",{sport:t,format:s,teams:r});return a.success?{success:!0,data:a.data,message:`${t}のトーナメントを作成しました`}:a}catch(t){return{success:!1,error:"CREATE_TOURNAMENT_ERROR",message:"トーナメントの作成に失敗しました",details:t.message}}}async deleteTournament(e){try{this.validateSport(e);const t=await this.client.delete(`/tournaments/${e}`);return t.success?{success:!0,data:t.data,message:`${e}のトーナメントを削除しました`}:t}catch(t){return{success:!1,error:"DELETE_TOURNAMENT_ERROR",message:"トーナメントの削除に失敗しました",details:t.message}}}async updateTournamentStatus(e,t){try{this.validateSport(e);if(!["pending","active","completed","cancelled"].includes(t))throw new Error(`無効なステータスです: ${t}`);const s=await this.client.patch(`/tournaments/${e}/status`,{status:t});return s.success?{success:!0,data:s.data,message:`${e}のトーナメント状態を${t}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_STATUS_ERROR",message:"トーナメント状態の更新に失敗しました",details:s.message}}}async getTournamentStats(e){try{this.validateSport(e);const t=await this.client.get(`/tournaments/${e}/stats`);return t.success?{success:!0,data:t.data,message:`${e}の統計情報を取得しました`}:t}catch(t){return{success:!1,error:"GET_STATS_ERROR",message:"統計情報の取得に失敗しました",details:t.message}}}async getAvailableFormats(e){try{this.validateSport(e);const t=await this.client.get(`/tournaments/${e}/formats`);return t.success?{success:!0,data:t.data,message:`${e}の利用可能な形式一覧を取得しました`}:t}catch(t){return{success:!1,error:"GET_FORMATS_ERROR",message:"形式一覧の取得に失敗しました",details:t.message}}}getSupportedSports(){return{success:!0,data:this.supportedSports,message:"サポートされているスポーツ一覧"}}};const g=new class{constructor(e=d){this.client=e,this.supportedSports=["volleyball","table_tennis","soccer"],this.validStatuses=["pending","in_progress","completed","cancelled"]}validateSport(e){if(!e)throw new Error("スポーツ名が指定されていません");if(!this.supportedSports.includes(e))throw new Error(`サポートされていないスポーツです: ${e}`);return!0}validateMatchId(e){if(!e)throw new Error("試合IDが指定されていません");if("number"!=typeof e&&"string"!=typeof e)throw new Error("試合IDの形式が正しくありません");return!0}validateMatchResult(e){if(!e||"object"!=typeof e)throw new Error("試合結果データが正しくありません");const{score1:t,score2:s,winner:r}=e;if(void 0!==t&&("number"!=typeof t||t<0))throw new Error("チーム1のスコアが正しくありません");if(void 0!==s&&("number"!=typeof s||s<0))throw new Error("チーム2のスコアが正しくありません");if(void 0!==t&&void 0!==s&&void 0!==r&&("string"!=typeof r||""===r.trim()))throw new Error("勝者の情報が正しくありません");return!0}async getMatches(e,t={}){try{this.validateSport(e);const s=new URLSearchParams;t.status&&s.append("status",t.status),t.round&&s.append("round",t.round),t.limit&&s.append("limit",t.limit.toString()),t.offset&&s.append("offset",t.offset.toString());const r=s.toString(),a=`/matches/${e}${r?`?${r}`:""}`,n=await this.client.get(a);return n.success?{success:!0,data:n.data,message:`${e}の試合一覧を取得しました`}:n}catch(s){return{success:!1,error:"GET_MATCHES_ERROR",message:"試合一覧の取得に失敗しました",details:s.message}}}async getMatch(e){try{this.validateMatchId(e);const t=await this.client.get(`/matches/${e}`);return t.success?{success:!0,data:t.data,message:"試合詳細を取得しました"}:t}catch(t){return{success:!1,error:"GET_MATCH_ERROR",message:"試合詳細の取得に失敗しました",details:t.message}}}async updateMatch(e,t){try{this.validateMatchId(e),this.validateMatchResult(t);const s=await this.client.put(`/matches/${e}`,t);return s.success?{success:!0,data:s.data,message:"試合結果を更新しました"}:s}catch(s){return{success:!1,error:"UPDATE_MATCH_ERROR",message:"試合結果の更新に失敗しました",details:s.message}}}async createMatch(e){try{if(!e||"object"!=typeof e)throw new Error("試合データが正しくありません");const{sport:t,tournament_id:s,round:r,team1:a,team2:n,scheduled_at:i}=e;if(!t)throw new Error("スポーツが指定されていません");if(this.validateSport(t),!s)throw new Error("トーナメントIDが指定されていません");if(!r)throw new Error("ラウンドが指定されていません");if(!a||!n)throw new Error("対戦チームが正しく指定されていません");if(a===n)throw new Error("同じチーム同士の試合は作成できません");const o=await this.client.post("/matches",e);return o.success?{success:!0,data:o.data,message:"新しい試合を作成しました"}:o}catch(t){return{success:!1,error:"CREATE_MATCH_ERROR",message:"試合の作成に失敗しました",details:t.message}}}async deleteMatch(e){try{this.validateMatchId(e);const t=await this.client.delete(`/matches/${e}`);return t.success?{success:!0,data:t.data,message:"試合を削除しました"}:t}catch(t){return{success:!1,error:"DELETE_MATCH_ERROR",message:"試合の削除に失敗しました",details:t.message}}}async updateMatchStatus(e,t){try{if(this.validateMatchId(e),!this.validStatuses.includes(t))throw new Error(`無効なステータスです: ${t}`);const s=await this.client.patch(`/matches/${e}/status`,{status:t});return s.success?{success:!0,data:s.data,message:`試合状態を${t}に更新しました`}:s}catch(s){return{success:!1,error:"UPDATE_MATCH_STATUS_ERROR",message:"試合状態の更新に失敗しました",details:s.message}}}async getPendingMatches(e){try{this.validateSport(e);const t=await this.client.get(`/matches/${e}/pending`);return t.success?{success:!0,data:t.data,message:`${e}の未完了試合一覧を取得しました`}:t}catch(t){return{success:!1,error:"GET_PENDING_MATCHES_ERROR",message:"未完了試合一覧の取得に失敗しました",details:t.message}}}async updateMultipleMatches(e){try{if(!Array.isArray(e)||0===e.length)throw new Error("更新データが正しくありません");for(const s of e){if(!s.matchId)throw new Error("試合IDが指定されていない更新データがあります");this.validateMatchId(s.matchId),this.validateMatchResult(s.result)}const t=await this.client.put("/matches/batch",{updates:e});return t.success?{success:!0,data:t.data,message:`${e.length}件の試合結果を更新しました`}:t}catch(t){return{success:!1,error:"UPDATE_MULTIPLE_MATCHES_ERROR",message:"試合結果の一括更新に失敗しました",details:t.message}}}async getMatchStats(e){try{this.validateMatchId(e);const t=await this.client.get(`/matches/${e}/stats`);return t.success?{success:!0,data:t.data,message:"試合統計情報を取得しました"}:t}catch(t){return{success:!1,error:"GET_MATCH_STATS_ERROR",message:"試合統計情報の取得に失敗しました",details:t.message}}}async getNextMatch(e){try{this.validateSport(e);const t=await this.client.get(`/matches/${e}/next`);return t.success?{success:!0,data:t.data,message:`${e}の次の試合情報を取得しました`}:t}catch(t){return{success:!1,error:"GET_NEXT_MATCH_ERROR",message:"次の試合情報の取得に失敗しました",details:t.message}}}getSupportedSports(){return{success:!0,data:this.supportedSports,message:"サポートされているスポーツ一覧"}}getValidStatuses(){return{success:!0,data:this.validStatuses,message:"有効なステータス一覧"}}};export{o as A,i as E,l as a,s as b,n as c,c as g,u as i,g as m,m as t,a as u};
